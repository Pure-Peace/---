#![feature(proc_macro_diagnostic)]

use proc_macro::TokenStream as 代码流类型;
use quote::quote as 生成代码;
use syn as 艾死外恩;
use 艾死外恩::parse::{Parse as 解析特性, ParseStream as 解析流, Result as 结果};
use 艾死外恩::{
    parse_macro_input as 解析输入, Block as 代码块, Error as 解析错误, Ident as 字面值,
    Token as 保留字, Type as 类型,
};

use 啥玩楞儿::*;

mod 啥玩楞儿 {
    pub type 可选值<甲> = Option<甲>;
}

mod 自定义关键字 {
    use syn as 艾死外恩;
    use 艾死外恩::custom_keyword as 定义关键字;

    定义关键字!(公开);
    定义关键字!(函数名);
    定义关键字!(函数体);
    定义关键字!(返回值类型);
}

struct 函数定义 {
    公开: 可选值<自定义关键字::公开>,
    函数名: 字面值,
    函数体: 代码块,
    返回值类型: 可选值<类型>,
}

fn 解析函数名(代码流: 解析流) -> 结果<字面值> {
    fn 函数名解析错误(代码流: 解析流) -> 解析错误 {
        解析错误::new(代码流.span(), "您应完整编写：函数名: xxx;")
    }

    if 代码流
        .parse::<可选值<自定义关键字::函数名>>()
        .map_err(|_| 函数名解析错误(代码流))?
        .is_some()
    {
        代码流
            .parse::<保留字![:]>()
            .map_err(|_| 函数名解析错误(代码流))?;
    }

    let 函数名 = 代码流.parse()?;

    代码流
        .parse::<保留字![;]>()
        .map_err(|_| 函数名解析错误(代码流))?;

    Ok(函数名)
}

fn 解析函数体(代码流: 解析流) -> 结果<代码块> {
    fn 函数体解析错误(代码流: 解析流) -> 解析错误 {
        解析错误::new(代码流.span(), "您应完整编写：函数体: { xxx };")
    }

    代码流
        .parse::<自定义关键字::函数体>()
        .map_err(|_| 函数体解析错误(代码流))?;
    代码流
        .parse::<保留字![:]>()
        .map_err(|_| 函数体解析错误(代码流))?;

    let 函数体 = 代码流.parse()?;

    代码流
        .parse::<保留字![;]>()
        .map_err(|_| 函数体解析错误(代码流))?;

    Ok(函数体)
}

fn 解析返回值类型(代码流: 解析流) -> 结果<可选值<类型>> {
    fn 返回值类型解析错误(代码流: 解析流) -> 解析错误 {
        解析错误::new(代码流.span(), "您应完整编写：返回值类型: xxx;")
    }

    if 代码流
        .parse::<可选值<自定义关键字::返回值类型>>()
        .map_err(|_| 返回值类型解析错误(代码流))?
        .is_none()
    {
        return Ok(None);
    };

    代码流
        .parse::<保留字![:]>()
        .map_err(|_| 返回值类型解析错误(代码流))?;

    let 函数名 = 代码流.parse()?;

    代码流
        .parse::<保留字![;]>()
        .map_err(|_| 返回值类型解析错误(代码流))?;

    Ok(Some(函数名))
}

impl 解析特性 for 函数定义 {
    fn parse(代码流: 解析流) -> 结果<Self> {
        let 公开 = 代码流.parse()?;
        代码流.parse::<可选值<保留字![;]>>()?;

        let 函数名 = 解析函数名(代码流)?;
        let 返回值类型 = 解析返回值类型(代码流)?;
        let 函数体 = 解析函数体(代码流)?;

        Ok(函数定义 {
            公开,
            函数名,
            函数体,
            返回值类型,
        })
    }
}

/* #[proc_macro]
pub fn 函数(代码流: 代码流类型) -> 代码流类型 {
    let 函数定义 {
        公开,
        函数名,
        函数体,
        返回值类型,
    } = 解析输入!(代码流 as 函数定义);

    let 可见性 = 公开.map(|_| 生成代码! { pub });
    let 返回值类型 = 返回值类型.unwrap_or(艾死外恩::parse_str("()").unwrap());

    let 代码展开 = 生成代码! {
        #可见性 fn #函数名() -> #返回值类型 #函数体
    };

    代码流类型::from(代码展开)
}
 */